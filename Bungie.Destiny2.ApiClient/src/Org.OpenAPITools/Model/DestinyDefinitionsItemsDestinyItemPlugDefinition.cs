/*
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Org.OpenAPITools.Client.OpenAPIDateConverter;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an instance of one of these bad boys.  This gives information about when it can be inserted, what the plug&#39;s category is (and thus whether it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug Categories and socket compatibility), whether it is enabled and other Plug info.
    /// </summary>
    [DataContract(Name = "Destiny.Definitions.Items.DestinyItemPlugDefinition")]
    public partial class DestinyDefinitionsItemsDestinyItemPlugDefinition : IEquatable<DestinyDefinitionsItemsDestinyItemPlugDefinition>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DestinyDefinitionsItemsDestinyItemPlugDefinition" /> class.
        /// </summary>
        /// <param name="insertionRules">The rules around when this plug can be inserted into a socket, aside from the socket&#39;s individual restrictions.  The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user..</param>
        /// <param name="plugCategoryIdentifier">The string identifier for the plug&#39;s category. Use the socket&#39;s DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket..</param>
        /// <param name="plugCategoryHash">The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes..</param>
        /// <param name="onActionRecreateSelf">If you successfully socket the item, this will determine whether or not you get \&quot;refunded\&quot; on the plug..</param>
        /// <param name="insertionMaterialRequirementHash">If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements..</param>
        /// <param name="previewItemOverrideHash">In the game, if you&#39;re inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item..</param>
        /// <param name="enabledMaterialRequirementHash">It&#39;s not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one..</param>
        /// <param name="enabledRules">The rules around whether the plug, once inserted, is enabled and providing its benefits.  The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user..</param>
        /// <param name="uiPlugLabel">Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance warning of when new labels might be applied or how that relates to how they get rendered. If you want to, you can refer to known labels to change your own styles: but know that new ones can be created arbitrarily, and we have no way of associating the labels with any specific UI style guidance... you&#39;ll have to piece that together on your end. Or do what we do, and just show plugs more generically, without specialized styles..</param>
        /// <param name="plugStyle">plugStyle.</param>
        /// <param name="plugAvailability">Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for more information!.</param>
        /// <param name="alternateUiPlugLabel">If the plug meets certain state requirements, it may have an alternative label applied to it. This is the alternative label that will be applied in such a situation..</param>
        /// <param name="alternatePlugStyle">The alternate plug of the plug: only applies when the item is in states that only the server can know about and control, unfortunately. See AlternateUiPlugLabel for the related label info..</param>
        /// <param name="isDummyPlug">If TRUE, this plug is used for UI display purposes only, and doesn&#39;t have any interesting effects of its own..</param>
        /// <param name="parentItemOverride">parentItemOverride.</param>
        /// <param name="energyCapacity">energyCapacity.</param>
        /// <param name="energyCost">energyCost.</param>
        public DestinyDefinitionsItemsDestinyItemPlugDefinition(List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> insertionRules = default(List<DestinyDefinitionsItemsDestinyPlugRuleDefinition>), string plugCategoryIdentifier = default(string), int plugCategoryHash = default(int), bool onActionRecreateSelf = default(bool), int insertionMaterialRequirementHash = default(int), int previewItemOverrideHash = default(int), int enabledMaterialRequirementHash = default(int), List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> enabledRules = default(List<DestinyDefinitionsItemsDestinyPlugRuleDefinition>), string uiPlugLabel = default(string), int plugStyle = default(int), int plugAvailability = default(int), string alternateUiPlugLabel = default(string), int alternatePlugStyle = default(int), bool isDummyPlug = default(bool), DestinyDefinitionsItemsDestinyParentItemOverride parentItemOverride = default(DestinyDefinitionsItemsDestinyParentItemOverride), DestinyDefinitionsItemsDestinyEnergyCapacityEntry energyCapacity = default(DestinyDefinitionsItemsDestinyEnergyCapacityEntry), DestinyDefinitionsItemsDestinyEnergyCostEntry energyCost = default(DestinyDefinitionsItemsDestinyEnergyCostEntry))
        {
            this.InsertionRules = insertionRules;
            this.PlugCategoryIdentifier = plugCategoryIdentifier;
            this.PlugCategoryHash = plugCategoryHash;
            this.OnActionRecreateSelf = onActionRecreateSelf;
            this.InsertionMaterialRequirementHash = insertionMaterialRequirementHash;
            this.PreviewItemOverrideHash = previewItemOverrideHash;
            this.EnabledMaterialRequirementHash = enabledMaterialRequirementHash;
            this.EnabledRules = enabledRules;
            this.UiPlugLabel = uiPlugLabel;
            this.PlugStyle = plugStyle;
            this.PlugAvailability = plugAvailability;
            this.AlternateUiPlugLabel = alternateUiPlugLabel;
            this.AlternatePlugStyle = alternatePlugStyle;
            this.IsDummyPlug = isDummyPlug;
            this.ParentItemOverride = parentItemOverride;
            this.EnergyCapacity = energyCapacity;
            this.EnergyCost = energyCost;
        }

        /// <summary>
        /// The rules around when this plug can be inserted into a socket, aside from the socket&#39;s individual restrictions.  The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
        /// </summary>
        /// <value>The rules around when this plug can be inserted into a socket, aside from the socket&#39;s individual restrictions.  The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.</value>
        [DataMember(Name = "insertionRules", EmitDefaultValue = false)]
        public List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> InsertionRules { get; set; }

        /// <summary>
        /// The string identifier for the plug&#39;s category. Use the socket&#39;s DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.
        /// </summary>
        /// <value>The string identifier for the plug&#39;s category. Use the socket&#39;s DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.</value>
        [DataMember(Name = "plugCategoryIdentifier", EmitDefaultValue = false)]
        public string PlugCategoryIdentifier { get; set; }

        /// <summary>
        /// The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.
        /// </summary>
        /// <value>The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.</value>
        [DataMember(Name = "plugCategoryHash", EmitDefaultValue = false)]
        public int PlugCategoryHash { get; set; }

        /// <summary>
        /// If you successfully socket the item, this will determine whether or not you get \&quot;refunded\&quot; on the plug.
        /// </summary>
        /// <value>If you successfully socket the item, this will determine whether or not you get \&quot;refunded\&quot; on the plug.</value>
        [DataMember(Name = "onActionRecreateSelf", EmitDefaultValue = true)]
        public bool OnActionRecreateSelf { get; set; }

        /// <summary>
        /// If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.
        /// </summary>
        /// <value>If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.</value>
        [DataMember(Name = "insertionMaterialRequirementHash", EmitDefaultValue = false)]
        public int InsertionMaterialRequirementHash { get; set; }

        /// <summary>
        /// In the game, if you&#39;re inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.
        /// </summary>
        /// <value>In the game, if you&#39;re inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.</value>
        [DataMember(Name = "previewItemOverrideHash", EmitDefaultValue = false)]
        public int PreviewItemOverrideHash { get; set; }

        /// <summary>
        /// It&#39;s not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.
        /// </summary>
        /// <value>It&#39;s not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.</value>
        [DataMember(Name = "enabledMaterialRequirementHash", EmitDefaultValue = false)]
        public int EnabledMaterialRequirementHash { get; set; }

        /// <summary>
        /// The rules around whether the plug, once inserted, is enabled and providing its benefits.  The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
        /// </summary>
        /// <value>The rules around whether the plug, once inserted, is enabled and providing its benefits.  The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.</value>
        [DataMember(Name = "enabledRules", EmitDefaultValue = false)]
        public List<DestinyDefinitionsItemsDestinyPlugRuleDefinition> EnabledRules { get; set; }

        /// <summary>
        /// Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance warning of when new labels might be applied or how that relates to how they get rendered. If you want to, you can refer to known labels to change your own styles: but know that new ones can be created arbitrarily, and we have no way of associating the labels with any specific UI style guidance... you&#39;ll have to piece that together on your end. Or do what we do, and just show plugs more generically, without specialized styles.
        /// </summary>
        /// <value>Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance warning of when new labels might be applied or how that relates to how they get rendered. If you want to, you can refer to known labels to change your own styles: but know that new ones can be created arbitrarily, and we have no way of associating the labels with any specific UI style guidance... you&#39;ll have to piece that together on your end. Or do what we do, and just show plugs more generically, without specialized styles.</value>
        [DataMember(Name = "uiPlugLabel", EmitDefaultValue = false)]
        public string UiPlugLabel { get; set; }

        /// <summary>
        /// Gets or Sets PlugStyle
        /// </summary>
        [DataMember(Name = "plugStyle", EmitDefaultValue = false)]
        public int PlugStyle { get; set; }

        /// <summary>
        /// Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for more information!
        /// </summary>
        /// <value>Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for more information!</value>
        [DataMember(Name = "plugAvailability", EmitDefaultValue = false)]
        public int PlugAvailability { get; set; }

        /// <summary>
        /// If the plug meets certain state requirements, it may have an alternative label applied to it. This is the alternative label that will be applied in such a situation.
        /// </summary>
        /// <value>If the plug meets certain state requirements, it may have an alternative label applied to it. This is the alternative label that will be applied in such a situation.</value>
        [DataMember(Name = "alternateUiPlugLabel", EmitDefaultValue = false)]
        public string AlternateUiPlugLabel { get; set; }

        /// <summary>
        /// The alternate plug of the plug: only applies when the item is in states that only the server can know about and control, unfortunately. See AlternateUiPlugLabel for the related label info.
        /// </summary>
        /// <value>The alternate plug of the plug: only applies when the item is in states that only the server can know about and control, unfortunately. See AlternateUiPlugLabel for the related label info.</value>
        [DataMember(Name = "alternatePlugStyle", EmitDefaultValue = false)]
        public int AlternatePlugStyle { get; set; }

        /// <summary>
        /// If TRUE, this plug is used for UI display purposes only, and doesn&#39;t have any interesting effects of its own.
        /// </summary>
        /// <value>If TRUE, this plug is used for UI display purposes only, and doesn&#39;t have any interesting effects of its own.</value>
        [DataMember(Name = "isDummyPlug", EmitDefaultValue = true)]
        public bool IsDummyPlug { get; set; }

        /// <summary>
        /// Gets or Sets ParentItemOverride
        /// </summary>
        [DataMember(Name = "parentItemOverride", EmitDefaultValue = false)]
        public DestinyDefinitionsItemsDestinyParentItemOverride ParentItemOverride { get; set; }

        /// <summary>
        /// Gets or Sets EnergyCapacity
        /// </summary>
        [DataMember(Name = "energyCapacity", EmitDefaultValue = false)]
        public DestinyDefinitionsItemsDestinyEnergyCapacityEntry EnergyCapacity { get; set; }

        /// <summary>
        /// Gets or Sets EnergyCost
        /// </summary>
        [DataMember(Name = "energyCost", EmitDefaultValue = false)]
        public DestinyDefinitionsItemsDestinyEnergyCostEntry EnergyCost { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DestinyDefinitionsItemsDestinyItemPlugDefinition {\n");
            sb.Append("  InsertionRules: ").Append(InsertionRules).Append("\n");
            sb.Append("  PlugCategoryIdentifier: ").Append(PlugCategoryIdentifier).Append("\n");
            sb.Append("  PlugCategoryHash: ").Append(PlugCategoryHash).Append("\n");
            sb.Append("  OnActionRecreateSelf: ").Append(OnActionRecreateSelf).Append("\n");
            sb.Append("  InsertionMaterialRequirementHash: ").Append(InsertionMaterialRequirementHash).Append("\n");
            sb.Append("  PreviewItemOverrideHash: ").Append(PreviewItemOverrideHash).Append("\n");
            sb.Append("  EnabledMaterialRequirementHash: ").Append(EnabledMaterialRequirementHash).Append("\n");
            sb.Append("  EnabledRules: ").Append(EnabledRules).Append("\n");
            sb.Append("  UiPlugLabel: ").Append(UiPlugLabel).Append("\n");
            sb.Append("  PlugStyle: ").Append(PlugStyle).Append("\n");
            sb.Append("  PlugAvailability: ").Append(PlugAvailability).Append("\n");
            sb.Append("  AlternateUiPlugLabel: ").Append(AlternateUiPlugLabel).Append("\n");
            sb.Append("  AlternatePlugStyle: ").Append(AlternatePlugStyle).Append("\n");
            sb.Append("  IsDummyPlug: ").Append(IsDummyPlug).Append("\n");
            sb.Append("  ParentItemOverride: ").Append(ParentItemOverride).Append("\n");
            sb.Append("  EnergyCapacity: ").Append(EnergyCapacity).Append("\n");
            sb.Append("  EnergyCost: ").Append(EnergyCost).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DestinyDefinitionsItemsDestinyItemPlugDefinition);
        }

        /// <summary>
        /// Returns true if DestinyDefinitionsItemsDestinyItemPlugDefinition instances are equal
        /// </summary>
        /// <param name="input">Instance of DestinyDefinitionsItemsDestinyItemPlugDefinition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DestinyDefinitionsItemsDestinyItemPlugDefinition input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.InsertionRules == input.InsertionRules ||
                    this.InsertionRules != null &&
                    input.InsertionRules != null &&
                    this.InsertionRules.SequenceEqual(input.InsertionRules)
                ) && 
                (
                    this.PlugCategoryIdentifier == input.PlugCategoryIdentifier ||
                    (this.PlugCategoryIdentifier != null &&
                    this.PlugCategoryIdentifier.Equals(input.PlugCategoryIdentifier))
                ) && 
                (
                    this.PlugCategoryHash == input.PlugCategoryHash ||
                    this.PlugCategoryHash.Equals(input.PlugCategoryHash)
                ) && 
                (
                    this.OnActionRecreateSelf == input.OnActionRecreateSelf ||
                    this.OnActionRecreateSelf.Equals(input.OnActionRecreateSelf)
                ) && 
                (
                    this.InsertionMaterialRequirementHash == input.InsertionMaterialRequirementHash ||
                    this.InsertionMaterialRequirementHash.Equals(input.InsertionMaterialRequirementHash)
                ) && 
                (
                    this.PreviewItemOverrideHash == input.PreviewItemOverrideHash ||
                    this.PreviewItemOverrideHash.Equals(input.PreviewItemOverrideHash)
                ) && 
                (
                    this.EnabledMaterialRequirementHash == input.EnabledMaterialRequirementHash ||
                    this.EnabledMaterialRequirementHash.Equals(input.EnabledMaterialRequirementHash)
                ) && 
                (
                    this.EnabledRules == input.EnabledRules ||
                    this.EnabledRules != null &&
                    input.EnabledRules != null &&
                    this.EnabledRules.SequenceEqual(input.EnabledRules)
                ) && 
                (
                    this.UiPlugLabel == input.UiPlugLabel ||
                    (this.UiPlugLabel != null &&
                    this.UiPlugLabel.Equals(input.UiPlugLabel))
                ) && 
                (
                    this.PlugStyle == input.PlugStyle ||
                    this.PlugStyle.Equals(input.PlugStyle)
                ) && 
                (
                    this.PlugAvailability == input.PlugAvailability ||
                    this.PlugAvailability.Equals(input.PlugAvailability)
                ) && 
                (
                    this.AlternateUiPlugLabel == input.AlternateUiPlugLabel ||
                    (this.AlternateUiPlugLabel != null &&
                    this.AlternateUiPlugLabel.Equals(input.AlternateUiPlugLabel))
                ) && 
                (
                    this.AlternatePlugStyle == input.AlternatePlugStyle ||
                    this.AlternatePlugStyle.Equals(input.AlternatePlugStyle)
                ) && 
                (
                    this.IsDummyPlug == input.IsDummyPlug ||
                    this.IsDummyPlug.Equals(input.IsDummyPlug)
                ) && 
                (
                    this.ParentItemOverride == input.ParentItemOverride ||
                    (this.ParentItemOverride != null &&
                    this.ParentItemOverride.Equals(input.ParentItemOverride))
                ) && 
                (
                    this.EnergyCapacity == input.EnergyCapacity ||
                    (this.EnergyCapacity != null &&
                    this.EnergyCapacity.Equals(input.EnergyCapacity))
                ) && 
                (
                    this.EnergyCost == input.EnergyCost ||
                    (this.EnergyCost != null &&
                    this.EnergyCost.Equals(input.EnergyCost))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.InsertionRules != null)
                {
                    hashCode = (hashCode * 59) + this.InsertionRules.GetHashCode();
                }
                if (this.PlugCategoryIdentifier != null)
                {
                    hashCode = (hashCode * 59) + this.PlugCategoryIdentifier.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.PlugCategoryHash.GetHashCode();
                hashCode = (hashCode * 59) + this.OnActionRecreateSelf.GetHashCode();
                hashCode = (hashCode * 59) + this.InsertionMaterialRequirementHash.GetHashCode();
                hashCode = (hashCode * 59) + this.PreviewItemOverrideHash.GetHashCode();
                hashCode = (hashCode * 59) + this.EnabledMaterialRequirementHash.GetHashCode();
                if (this.EnabledRules != null)
                {
                    hashCode = (hashCode * 59) + this.EnabledRules.GetHashCode();
                }
                if (this.UiPlugLabel != null)
                {
                    hashCode = (hashCode * 59) + this.UiPlugLabel.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.PlugStyle.GetHashCode();
                hashCode = (hashCode * 59) + this.PlugAvailability.GetHashCode();
                if (this.AlternateUiPlugLabel != null)
                {
                    hashCode = (hashCode * 59) + this.AlternateUiPlugLabel.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.AlternatePlugStyle.GetHashCode();
                hashCode = (hashCode * 59) + this.IsDummyPlug.GetHashCode();
                if (this.ParentItemOverride != null)
                {
                    hashCode = (hashCode * 59) + this.ParentItemOverride.GetHashCode();
                }
                if (this.EnergyCapacity != null)
                {
                    hashCode = (hashCode * 59) + this.EnergyCapacity.GetHashCode();
                }
                if (this.EnergyCost != null)
                {
                    hashCode = (hashCode * 59) + this.EnergyCost.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
