/*
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.18.0
 * Contact: support@bungie.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Org.OpenAPITools.Client.OpenAPIDateConverter;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// So much of what you see in Destiny is actually an Item used in a new and creative way. This is the definition for Items in Destiny, which started off as just entities that could exist in your Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and subclasses.  In practice, you will want to associate this data with \&quot;live\&quot; item data from a Bungie.Net Platform call: these definitions describe the item in generic, non-instanced terms: but an actual instance of an item can vary widely from these generic definitions.
    /// </summary>
    [DataContract(Name = "Destiny.Definitions.DestinyInventoryItemDefinition")]
    public partial class DestinyDefinitionsDestinyInventoryItemDefinition : IEquatable<DestinyDefinitionsDestinyInventoryItemDefinition>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DestinyDefinitionsDestinyInventoryItemDefinition" /> class.
        /// </summary>
        /// <param name="displayProperties">displayProperties.</param>
        /// <param name="tooltipNotifications">Tooltips that only come up conditionally for the item. Check the live data DestinyItemComponent.tooltipNotificationIndexes property for which of these should be shown at runtime..</param>
        /// <param name="collectibleHash">If this item has a collectible related to it, this is the hash identifier of that collectible entry..</param>
        /// <param name="iconWatermark">If available, this is the original &#39;active&#39; release watermark overlay for the icon. If the item has different versions, this can be overridden by the &#39;display version watermark icon&#39; from the &#39;quality&#39; block. Alternatively, if there is no watermark for the version, and the item version has a power cap below the current season power cap, this can be overridden by the iconWatermarkShelved property..</param>
        /// <param name="iconWatermarkShelved">If available, this is the &#39;shelved&#39; release watermark overlay for the icon. If the item version has a power cap below the current season power cap, it can be treated as &#39;shelved&#39;, and should be shown with this &#39;shelved&#39; watermark overlay..</param>
        /// <param name="secondaryIcon">A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates..</param>
        /// <param name="secondaryOverlay">Pulled from the secondary icon, this is the \&quot;secondary background\&quot; of the secondary icon. Confusing? Sure, that&#39;s why I call it \&quot;overlay\&quot; here: because as far as it&#39;s been used thus far, it has been for an optional overlay image. We&#39;ll see if that holds up, but at least for now it explains what this image is a bit better..</param>
        /// <param name="secondarySpecial">Pulled from the Secondary Icon, this is the \&quot;special\&quot; background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items..</param>
        /// <param name="backgroundColor">backgroundColor.</param>
        /// <param name="screenshot">If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items..</param>
        /// <param name="itemTypeDisplayName">The localized title/name of the item&#39;s type. This can be whatever the designers want, and has no guarantee of consistency between items..</param>
        /// <param name="flavorText">flavorText.</param>
        /// <param name="uiItemDisplayStyle">A string identifier that the game&#39;s UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don&#39;t have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!.</param>
        /// <param name="itemTypeAndTierDisplayName">It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I&#39;m just going to go ahead and start pre-creating these for items..</param>
        /// <param name="displaySource">In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it&#39;s instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property..</param>
        /// <param name="tooltipStyle">An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it&#39;ll be up to you to interpret and display your UI differently according to these styles (or ignore it)..</param>
        /// <param name="action">action.</param>
        /// <param name="crafting">crafting.</param>
        /// <param name="inventory">inventory.</param>
        /// <param name="setData">setData.</param>
        /// <param name="stats">stats.</param>
        /// <param name="emblemObjectiveHash">If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the \&quot;art channel\&quot;. When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they&#39;re being used for and how they are wired up, but for now here&#39;s the raw data..</param>
        /// <param name="equippingBlock">equippingBlock.</param>
        /// <param name="translationBlock">translationBlock.</param>
        /// <param name="preview">preview.</param>
        /// <param name="quality">quality.</param>
        /// <param name="value">value.</param>
        /// <param name="sourceData">sourceData.</param>
        /// <param name="objectives">objectives.</param>
        /// <param name="metrics">metrics.</param>
        /// <param name="plug">plug.</param>
        /// <param name="gearset">gearset.</param>
        /// <param name="sack">sack.</param>
        /// <param name="sockets">sockets.</param>
        /// <param name="summary">summary.</param>
        /// <param name="talentGrid">talentGrid.</param>
        /// <param name="investmentStats">If the item has stats, this block will be defined. It has the \&quot;raw\&quot; investment stats for the item. These investment stats don&#39;t take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them..</param>
        /// <param name="perks">If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here..</param>
        /// <param name="loreHash">If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition..</param>
        /// <param name="summaryItemHash">There are times when the game will show you a \&quot;summary/vague\&quot; version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.  This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists..</param>
        /// <param name="animations">If any animations were extracted from game content for this item, these will be the definitions of those animations..</param>
        /// <param name="allowActions">BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false..</param>
        /// <param name="links">If we added any help or informational URLs about this item, these will be those links..</param>
        /// <param name="doesPostmasterPullHaveSideEffects">The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a \&quot;destructive\&quot; action.  It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you&#39;ll end up receiving an error..</param>
        /// <param name="nonTransferrable">The intrinsic transferability of an item.  I hate that this boolean is negative - but there&#39;s a reason.  Just because an item is intrinsically transferrable doesn&#39;t mean that it can be transferred, and we don&#39;t want to imply that this is the only source of that transferability..</param>
        /// <param name="itemCategoryHashes">BNet attempts to make a more formal definition of item \&quot;Categories\&quot;, as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it&#39;s a \&quot;Weapon\&quot;, that it&#39;s an \&quot;Auto Rifle\&quot;, etc...)  The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums..</param>
        /// <param name="specialItemType">In Destiny 1, we identified some items as having particular categories that we&#39;d like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience..</param>
        /// <param name="itemType">A value indicating the \&quot;base\&quot; the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a \&quot;Type\&quot;. Still, it&#39;s handy in many situations.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience..</param>
        /// <param name="itemSubType">A value indicating the \&quot;sub-type\&quot; of the item. For instance, where an item might have an itemType value \&quot;Weapon\&quot;, this will be something more specific like \&quot;Auto Rifle\&quot;.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience..</param>
        /// <param name="classType">We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class&#39; enumeration value so that users can easily identify class restricted items.  If you see a mis-classed item, please inform the developers in the Bungie API forum..</param>
        /// <param name="breakerType">Some weapons and plugs can have a \&quot;Breaker Type\&quot;: a special ability that works sort of like damage type vulnerabilities. This is (almost?) always set on items by plugs..</param>
        /// <param name="breakerTypeHash">Since we also have a breaker type definition, this is the hash for that breaker type for your convenience. Whether you use the enum or hash and look up the definition depends on what&#39;s cleanest for your code..</param>
        /// <param name="equippable">If true, then you will be allowed to equip the item if you pass its other requirements.  This being false means that you cannot equip the item under any circumstances..</param>
        /// <param name="damageTypeHashes">Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default..</param>
        /// <param name="damageTypes">This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.  This damage type prediction will only use the following to determine potential damage types:  - Intrinsic perks  - Talent Node perks  - Known, reusable plugs for sockets.</param>
        /// <param name="defaultDamageType">If the item has a damage type that could be considered to be default, it will be populated here.  For various upsetting reasons, it&#39;s surprisingly cumbersome to figure this out. I hope you&#39;re happy..</param>
        /// <param name="defaultDamageTypeHash">Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.  I will likely regret leaving in the enumeration versions of these properties, but for now they&#39;re very convenient..</param>
        /// <param name="seasonHash">If this item is related directly to a Season of Destiny, this is the hash identifier for that season..</param>
        /// <param name="isWrapper">If true, this is a dummy vendor-wrapped item template. Items purchased from Eververse will be \&quot;wrapped\&quot; by one of these items so that we can safely provide refund capabilities before the item is \&quot;unwrapped\&quot;..</param>
        /// <param name="traitIds">Traits are metadata tags applied to this item. For example: armor slot, weapon type, foundry, faction, etc. These IDs come from the game and don&#39;t map to any content, but should still be useful..</param>
        /// <param name="traitHashes">These are the corresponding trait definition hashes for the entries in traitIds..</param>
        /// <param name="hash">The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to..</param>
        /// <param name="index">The index of the entity as it was found in the investment tables..</param>
        /// <param name="redacted">If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!.</param>
        public DestinyDefinitionsDestinyInventoryItemDefinition(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition displayProperties = default(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition), List<DestinyDefinitionsDestinyItemTooltipNotification> tooltipNotifications = default(List<DestinyDefinitionsDestinyItemTooltipNotification>), int? collectibleHash = default(int?), string iconWatermark = default(string), string iconWatermarkShelved = default(string), string secondaryIcon = default(string), string secondaryOverlay = default(string), string secondarySpecial = default(string), DestinyMiscDestinyColor backgroundColor = default(DestinyMiscDestinyColor), string screenshot = default(string), string itemTypeDisplayName = default(string), string flavorText = default(string), string uiItemDisplayStyle = default(string), string itemTypeAndTierDisplayName = default(string), string displaySource = default(string), string tooltipStyle = default(string), DestinyDefinitionsDestinyItemActionBlockDefinition action = default(DestinyDefinitionsDestinyItemActionBlockDefinition), DestinyDefinitionsDestinyItemCraftingBlockDefinition crafting = default(DestinyDefinitionsDestinyItemCraftingBlockDefinition), DestinyDefinitionsDestinyItemInventoryBlockDefinition inventory = default(DestinyDefinitionsDestinyItemInventoryBlockDefinition), DestinyDefinitionsDestinyItemSetBlockDefinition setData = default(DestinyDefinitionsDestinyItemSetBlockDefinition), DestinyDefinitionsDestinyItemStatBlockDefinition stats = default(DestinyDefinitionsDestinyItemStatBlockDefinition), int? emblemObjectiveHash = default(int?), DestinyDefinitionsDestinyEquippingBlockDefinition equippingBlock = default(DestinyDefinitionsDestinyEquippingBlockDefinition), DestinyDefinitionsDestinyItemTranslationBlockDefinition translationBlock = default(DestinyDefinitionsDestinyItemTranslationBlockDefinition), DestinyDefinitionsDestinyItemPreviewBlockDefinition preview = default(DestinyDefinitionsDestinyItemPreviewBlockDefinition), DestinyDefinitionsDestinyItemQualityBlockDefinition quality = default(DestinyDefinitionsDestinyItemQualityBlockDefinition), DestinyDefinitionsDestinyItemValueBlockDefinition value = default(DestinyDefinitionsDestinyItemValueBlockDefinition), DestinyDefinitionsDestinyItemSourceBlockDefinition sourceData = default(DestinyDefinitionsDestinyItemSourceBlockDefinition), DestinyDefinitionsDestinyItemObjectiveBlockDefinition objectives = default(DestinyDefinitionsDestinyItemObjectiveBlockDefinition), DestinyDefinitionsDestinyItemMetricBlockDefinition metrics = default(DestinyDefinitionsDestinyItemMetricBlockDefinition), DestinyDefinitionsItemsDestinyItemPlugDefinition plug = default(DestinyDefinitionsItemsDestinyItemPlugDefinition), DestinyDefinitionsDestinyItemGearsetBlockDefinition gearset = default(DestinyDefinitionsDestinyItemGearsetBlockDefinition), DestinyDefinitionsDestinyItemSackBlockDefinition sack = default(DestinyDefinitionsDestinyItemSackBlockDefinition), DestinyDefinitionsDestinyItemSocketBlockDefinition sockets = default(DestinyDefinitionsDestinyItemSocketBlockDefinition), DestinyDefinitionsDestinyItemSummaryBlockDefinition summary = default(DestinyDefinitionsDestinyItemSummaryBlockDefinition), DestinyDefinitionsDestinyItemTalentGridBlockDefinition talentGrid = default(DestinyDefinitionsDestinyItemTalentGridBlockDefinition), List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> investmentStats = default(List<DestinyDefinitionsDestinyItemInvestmentStatDefinition>), List<DestinyDefinitionsDestinyItemPerkEntryDefinition> perks = default(List<DestinyDefinitionsDestinyItemPerkEntryDefinition>), int? loreHash = default(int?), int? summaryItemHash = default(int?), List<DestinyDefinitionsAnimationsDestinyAnimationReference> animations = default(List<DestinyDefinitionsAnimationsDestinyAnimationReference>), bool allowActions = default(bool), List<LinksHyperlinkReference> links = default(List<LinksHyperlinkReference>), bool doesPostmasterPullHaveSideEffects = default(bool), bool nonTransferrable = default(bool), List<int> itemCategoryHashes = default(List<int>), int specialItemType = default(int), int itemType = default(int), int itemSubType = default(int), int classType = default(int), int breakerType = default(int), int? breakerTypeHash = default(int?), bool equippable = default(bool), List<int> damageTypeHashes = default(List<int>), List<int> damageTypes = default(List<int>), int defaultDamageType = default(int), int? defaultDamageTypeHash = default(int?), int? seasonHash = default(int?), bool isWrapper = default(bool), List<string> traitIds = default(List<string>), List<int> traitHashes = default(List<int>), int hash = default(int), int index = default(int), bool redacted = default(bool))
        {
            this.DisplayProperties = displayProperties;
            this.TooltipNotifications = tooltipNotifications;
            this.CollectibleHash = collectibleHash;
            this.IconWatermark = iconWatermark;
            this.IconWatermarkShelved = iconWatermarkShelved;
            this.SecondaryIcon = secondaryIcon;
            this.SecondaryOverlay = secondaryOverlay;
            this.SecondarySpecial = secondarySpecial;
            this.BackgroundColor = backgroundColor;
            this.Screenshot = screenshot;
            this.ItemTypeDisplayName = itemTypeDisplayName;
            this.FlavorText = flavorText;
            this.UiItemDisplayStyle = uiItemDisplayStyle;
            this.ItemTypeAndTierDisplayName = itemTypeAndTierDisplayName;
            this.DisplaySource = displaySource;
            this.TooltipStyle = tooltipStyle;
            this.Action = action;
            this.Crafting = crafting;
            this.Inventory = inventory;
            this.SetData = setData;
            this.Stats = stats;
            this.EmblemObjectiveHash = emblemObjectiveHash;
            this.EquippingBlock = equippingBlock;
            this.TranslationBlock = translationBlock;
            this.Preview = preview;
            this.Quality = quality;
            this.Value = value;
            this.SourceData = sourceData;
            this.Objectives = objectives;
            this.Metrics = metrics;
            this.Plug = plug;
            this.Gearset = gearset;
            this.Sack = sack;
            this.Sockets = sockets;
            this.Summary = summary;
            this.TalentGrid = talentGrid;
            this.InvestmentStats = investmentStats;
            this.Perks = perks;
            this.LoreHash = loreHash;
            this.SummaryItemHash = summaryItemHash;
            this.Animations = animations;
            this.AllowActions = allowActions;
            this.Links = links;
            this.DoesPostmasterPullHaveSideEffects = doesPostmasterPullHaveSideEffects;
            this.NonTransferrable = nonTransferrable;
            this.ItemCategoryHashes = itemCategoryHashes;
            this.SpecialItemType = specialItemType;
            this.ItemType = itemType;
            this.ItemSubType = itemSubType;
            this.ClassType = classType;
            this.BreakerType = breakerType;
            this.BreakerTypeHash = breakerTypeHash;
            this.Equippable = equippable;
            this.DamageTypeHashes = damageTypeHashes;
            this.DamageTypes = damageTypes;
            this.DefaultDamageType = defaultDamageType;
            this.DefaultDamageTypeHash = defaultDamageTypeHash;
            this.SeasonHash = seasonHash;
            this.IsWrapper = isWrapper;
            this.TraitIds = traitIds;
            this.TraitHashes = traitHashes;
            this.Hash = hash;
            this.Index = index;
            this.Redacted = redacted;
        }

        /// <summary>
        /// Gets or Sets DisplayProperties
        /// </summary>
        [DataMember(Name = "displayProperties", EmitDefaultValue = false)]
        public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition DisplayProperties { get; set; }

        /// <summary>
        /// Tooltips that only come up conditionally for the item. Check the live data DestinyItemComponent.tooltipNotificationIndexes property for which of these should be shown at runtime.
        /// </summary>
        /// <value>Tooltips that only come up conditionally for the item. Check the live data DestinyItemComponent.tooltipNotificationIndexes property for which of these should be shown at runtime.</value>
        [DataMember(Name = "tooltipNotifications", EmitDefaultValue = false)]
        public List<DestinyDefinitionsDestinyItemTooltipNotification> TooltipNotifications { get; set; }

        /// <summary>
        /// If this item has a collectible related to it, this is the hash identifier of that collectible entry.
        /// </summary>
        /// <value>If this item has a collectible related to it, this is the hash identifier of that collectible entry.</value>
        [DataMember(Name = "collectibleHash", EmitDefaultValue = true)]
        public int? CollectibleHash { get; set; }

        /// <summary>
        /// If available, this is the original &#39;active&#39; release watermark overlay for the icon. If the item has different versions, this can be overridden by the &#39;display version watermark icon&#39; from the &#39;quality&#39; block. Alternatively, if there is no watermark for the version, and the item version has a power cap below the current season power cap, this can be overridden by the iconWatermarkShelved property.
        /// </summary>
        /// <value>If available, this is the original &#39;active&#39; release watermark overlay for the icon. If the item has different versions, this can be overridden by the &#39;display version watermark icon&#39; from the &#39;quality&#39; block. Alternatively, if there is no watermark for the version, and the item version has a power cap below the current season power cap, this can be overridden by the iconWatermarkShelved property.</value>
        [DataMember(Name = "iconWatermark", EmitDefaultValue = false)]
        public string IconWatermark { get; set; }

        /// <summary>
        /// If available, this is the &#39;shelved&#39; release watermark overlay for the icon. If the item version has a power cap below the current season power cap, it can be treated as &#39;shelved&#39;, and should be shown with this &#39;shelved&#39; watermark overlay.
        /// </summary>
        /// <value>If available, this is the &#39;shelved&#39; release watermark overlay for the icon. If the item version has a power cap below the current season power cap, it can be treated as &#39;shelved&#39;, and should be shown with this &#39;shelved&#39; watermark overlay.</value>
        [DataMember(Name = "iconWatermarkShelved", EmitDefaultValue = false)]
        public string IconWatermarkShelved { get; set; }

        /// <summary>
        /// A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.
        /// </summary>
        /// <value>A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.</value>
        [DataMember(Name = "secondaryIcon", EmitDefaultValue = false)]
        public string SecondaryIcon { get; set; }

        /// <summary>
        /// Pulled from the secondary icon, this is the \&quot;secondary background\&quot; of the secondary icon. Confusing? Sure, that&#39;s why I call it \&quot;overlay\&quot; here: because as far as it&#39;s been used thus far, it has been for an optional overlay image. We&#39;ll see if that holds up, but at least for now it explains what this image is a bit better.
        /// </summary>
        /// <value>Pulled from the secondary icon, this is the \&quot;secondary background\&quot; of the secondary icon. Confusing? Sure, that&#39;s why I call it \&quot;overlay\&quot; here: because as far as it&#39;s been used thus far, it has been for an optional overlay image. We&#39;ll see if that holds up, but at least for now it explains what this image is a bit better.</value>
        [DataMember(Name = "secondaryOverlay", EmitDefaultValue = false)]
        public string SecondaryOverlay { get; set; }

        /// <summary>
        /// Pulled from the Secondary Icon, this is the \&quot;special\&quot; background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.
        /// </summary>
        /// <value>Pulled from the Secondary Icon, this is the \&quot;special\&quot; background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.</value>
        [DataMember(Name = "secondarySpecial", EmitDefaultValue = false)]
        public string SecondarySpecial { get; set; }

        /// <summary>
        /// Gets or Sets BackgroundColor
        /// </summary>
        [DataMember(Name = "backgroundColor", EmitDefaultValue = false)]
        public DestinyMiscDestinyColor BackgroundColor { get; set; }

        /// <summary>
        /// If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.
        /// </summary>
        /// <value>If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.</value>
        [DataMember(Name = "screenshot", EmitDefaultValue = false)]
        public string Screenshot { get; set; }

        /// <summary>
        /// The localized title/name of the item&#39;s type. This can be whatever the designers want, and has no guarantee of consistency between items.
        /// </summary>
        /// <value>The localized title/name of the item&#39;s type. This can be whatever the designers want, and has no guarantee of consistency between items.</value>
        [DataMember(Name = "itemTypeDisplayName", EmitDefaultValue = false)]
        public string ItemTypeDisplayName { get; set; }

        /// <summary>
        /// Gets or Sets FlavorText
        /// </summary>
        [DataMember(Name = "flavorText", EmitDefaultValue = false)]
        public string FlavorText { get; set; }

        /// <summary>
        /// A string identifier that the game&#39;s UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don&#39;t have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!
        /// </summary>
        /// <value>A string identifier that the game&#39;s UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don&#39;t have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!</value>
        [DataMember(Name = "uiItemDisplayStyle", EmitDefaultValue = false)]
        public string UiItemDisplayStyle { get; set; }

        /// <summary>
        /// It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I&#39;m just going to go ahead and start pre-creating these for items.
        /// </summary>
        /// <value>It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I&#39;m just going to go ahead and start pre-creating these for items.</value>
        [DataMember(Name = "itemTypeAndTierDisplayName", EmitDefaultValue = false)]
        public string ItemTypeAndTierDisplayName { get; set; }

        /// <summary>
        /// In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it&#39;s instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.
        /// </summary>
        /// <value>In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it&#39;s instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.</value>
        [DataMember(Name = "displaySource", EmitDefaultValue = false)]
        public string DisplaySource { get; set; }

        /// <summary>
        /// An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it&#39;ll be up to you to interpret and display your UI differently according to these styles (or ignore it).
        /// </summary>
        /// <value>An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it&#39;ll be up to you to interpret and display your UI differently according to these styles (or ignore it).</value>
        [DataMember(Name = "tooltipStyle", EmitDefaultValue = false)]
        public string TooltipStyle { get; set; }

        /// <summary>
        /// Gets or Sets Action
        /// </summary>
        [DataMember(Name = "action", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemActionBlockDefinition Action { get; set; }

        /// <summary>
        /// Gets or Sets Crafting
        /// </summary>
        [DataMember(Name = "crafting", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemCraftingBlockDefinition Crafting { get; set; }

        /// <summary>
        /// Gets or Sets Inventory
        /// </summary>
        [DataMember(Name = "inventory", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemInventoryBlockDefinition Inventory { get; set; }

        /// <summary>
        /// Gets or Sets SetData
        /// </summary>
        [DataMember(Name = "setData", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemSetBlockDefinition SetData { get; set; }

        /// <summary>
        /// Gets or Sets Stats
        /// </summary>
        [DataMember(Name = "stats", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemStatBlockDefinition Stats { get; set; }

        /// <summary>
        /// If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the \&quot;art channel\&quot;. When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they&#39;re being used for and how they are wired up, but for now here&#39;s the raw data.
        /// </summary>
        /// <value>If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the \&quot;art channel\&quot;. When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they&#39;re being used for and how they are wired up, but for now here&#39;s the raw data.</value>
        [DataMember(Name = "emblemObjectiveHash", EmitDefaultValue = true)]
        public int? EmblemObjectiveHash { get; set; }

        /// <summary>
        /// Gets or Sets EquippingBlock
        /// </summary>
        [DataMember(Name = "equippingBlock", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyEquippingBlockDefinition EquippingBlock { get; set; }

        /// <summary>
        /// Gets or Sets TranslationBlock
        /// </summary>
        [DataMember(Name = "translationBlock", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemTranslationBlockDefinition TranslationBlock { get; set; }

        /// <summary>
        /// Gets or Sets Preview
        /// </summary>
        [DataMember(Name = "preview", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemPreviewBlockDefinition Preview { get; set; }

        /// <summary>
        /// Gets or Sets Quality
        /// </summary>
        [DataMember(Name = "quality", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemQualityBlockDefinition Quality { get; set; }

        /// <summary>
        /// Gets or Sets Value
        /// </summary>
        [DataMember(Name = "value", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemValueBlockDefinition Value { get; set; }

        /// <summary>
        /// Gets or Sets SourceData
        /// </summary>
        [DataMember(Name = "sourceData", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemSourceBlockDefinition SourceData { get; set; }

        /// <summary>
        /// Gets or Sets Objectives
        /// </summary>
        [DataMember(Name = "objectives", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemObjectiveBlockDefinition Objectives { get; set; }

        /// <summary>
        /// Gets or Sets Metrics
        /// </summary>
        [DataMember(Name = "metrics", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemMetricBlockDefinition Metrics { get; set; }

        /// <summary>
        /// Gets or Sets Plug
        /// </summary>
        [DataMember(Name = "plug", EmitDefaultValue = false)]
        public DestinyDefinitionsItemsDestinyItemPlugDefinition Plug { get; set; }

        /// <summary>
        /// Gets or Sets Gearset
        /// </summary>
        [DataMember(Name = "gearset", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemGearsetBlockDefinition Gearset { get; set; }

        /// <summary>
        /// Gets or Sets Sack
        /// </summary>
        [DataMember(Name = "sack", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemSackBlockDefinition Sack { get; set; }

        /// <summary>
        /// Gets or Sets Sockets
        /// </summary>
        [DataMember(Name = "sockets", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemSocketBlockDefinition Sockets { get; set; }

        /// <summary>
        /// Gets or Sets Summary
        /// </summary>
        [DataMember(Name = "summary", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemSummaryBlockDefinition Summary { get; set; }

        /// <summary>
        /// Gets or Sets TalentGrid
        /// </summary>
        [DataMember(Name = "talentGrid", EmitDefaultValue = false)]
        public DestinyDefinitionsDestinyItemTalentGridBlockDefinition TalentGrid { get; set; }

        /// <summary>
        /// If the item has stats, this block will be defined. It has the \&quot;raw\&quot; investment stats for the item. These investment stats don&#39;t take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.
        /// </summary>
        /// <value>If the item has stats, this block will be defined. It has the \&quot;raw\&quot; investment stats for the item. These investment stats don&#39;t take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.</value>
        [DataMember(Name = "investmentStats", EmitDefaultValue = false)]
        public List<DestinyDefinitionsDestinyItemInvestmentStatDefinition> InvestmentStats { get; set; }

        /// <summary>
        /// If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.
        /// </summary>
        /// <value>If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.</value>
        [DataMember(Name = "perks", EmitDefaultValue = false)]
        public List<DestinyDefinitionsDestinyItemPerkEntryDefinition> Perks { get; set; }

        /// <summary>
        /// If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.
        /// </summary>
        /// <value>If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.</value>
        [DataMember(Name = "loreHash", EmitDefaultValue = true)]
        public int? LoreHash { get; set; }

        /// <summary>
        /// There are times when the game will show you a \&quot;summary/vague\&quot; version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.  This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.
        /// </summary>
        /// <value>There are times when the game will show you a \&quot;summary/vague\&quot; version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.  This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.</value>
        [DataMember(Name = "summaryItemHash", EmitDefaultValue = true)]
        public int? SummaryItemHash { get; set; }

        /// <summary>
        /// If any animations were extracted from game content for this item, these will be the definitions of those animations.
        /// </summary>
        /// <value>If any animations were extracted from game content for this item, these will be the definitions of those animations.</value>
        [DataMember(Name = "animations", EmitDefaultValue = false)]
        public List<DestinyDefinitionsAnimationsDestinyAnimationReference> Animations { get; set; }

        /// <summary>
        /// BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.
        /// </summary>
        /// <value>BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.</value>
        [DataMember(Name = "allowActions", EmitDefaultValue = true)]
        public bool AllowActions { get; set; }

        /// <summary>
        /// If we added any help or informational URLs about this item, these will be those links.
        /// </summary>
        /// <value>If we added any help or informational URLs about this item, these will be those links.</value>
        [DataMember(Name = "links", EmitDefaultValue = false)]
        public List<LinksHyperlinkReference> Links { get; set; }

        /// <summary>
        /// The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a \&quot;destructive\&quot; action.  It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you&#39;ll end up receiving an error.
        /// </summary>
        /// <value>The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a \&quot;destructive\&quot; action.  It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you&#39;ll end up receiving an error.</value>
        [DataMember(Name = "doesPostmasterPullHaveSideEffects", EmitDefaultValue = true)]
        public bool DoesPostmasterPullHaveSideEffects { get; set; }

        /// <summary>
        /// The intrinsic transferability of an item.  I hate that this boolean is negative - but there&#39;s a reason.  Just because an item is intrinsically transferrable doesn&#39;t mean that it can be transferred, and we don&#39;t want to imply that this is the only source of that transferability.
        /// </summary>
        /// <value>The intrinsic transferability of an item.  I hate that this boolean is negative - but there&#39;s a reason.  Just because an item is intrinsically transferrable doesn&#39;t mean that it can be transferred, and we don&#39;t want to imply that this is the only source of that transferability.</value>
        [DataMember(Name = "nonTransferrable", EmitDefaultValue = true)]
        public bool NonTransferrable { get; set; }

        /// <summary>
        /// BNet attempts to make a more formal definition of item \&quot;Categories\&quot;, as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it&#39;s a \&quot;Weapon\&quot;, that it&#39;s an \&quot;Auto Rifle\&quot;, etc...)  The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.
        /// </summary>
        /// <value>BNet attempts to make a more formal definition of item \&quot;Categories\&quot;, as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it&#39;s a \&quot;Weapon\&quot;, that it&#39;s an \&quot;Auto Rifle\&quot;, etc...)  The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.</value>
        [DataMember(Name = "itemCategoryHashes", EmitDefaultValue = false)]
        public List<int> ItemCategoryHashes { get; set; }

        /// <summary>
        /// In Destiny 1, we identified some items as having particular categories that we&#39;d like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
        /// </summary>
        /// <value>In Destiny 1, we identified some items as having particular categories that we&#39;d like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.</value>
        [DataMember(Name = "specialItemType", EmitDefaultValue = false)]
        public int SpecialItemType { get; set; }

        /// <summary>
        /// A value indicating the \&quot;base\&quot; the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a \&quot;Type\&quot;. Still, it&#39;s handy in many situations.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
        /// </summary>
        /// <value>A value indicating the \&quot;base\&quot; the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a \&quot;Type\&quot;. Still, it&#39;s handy in many situations.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.</value>
        [DataMember(Name = "itemType", EmitDefaultValue = false)]
        public int ItemType { get; set; }

        /// <summary>
        /// A value indicating the \&quot;sub-type\&quot; of the item. For instance, where an item might have an itemType value \&quot;Weapon\&quot;, this will be something more specific like \&quot;Auto Rifle\&quot;.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
        /// </summary>
        /// <value>A value indicating the \&quot;sub-type\&quot; of the item. For instance, where an item might have an itemType value \&quot;Weapon\&quot;, this will be something more specific like \&quot;Auto Rifle\&quot;.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.</value>
        [DataMember(Name = "itemSubType", EmitDefaultValue = false)]
        public int ItemSubType { get; set; }

        /// <summary>
        /// We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class&#39; enumeration value so that users can easily identify class restricted items.  If you see a mis-classed item, please inform the developers in the Bungie API forum.
        /// </summary>
        /// <value>We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class&#39; enumeration value so that users can easily identify class restricted items.  If you see a mis-classed item, please inform the developers in the Bungie API forum.</value>
        [DataMember(Name = "classType", EmitDefaultValue = false)]
        public int ClassType { get; set; }

        /// <summary>
        /// Some weapons and plugs can have a \&quot;Breaker Type\&quot;: a special ability that works sort of like damage type vulnerabilities. This is (almost?) always set on items by plugs.
        /// </summary>
        /// <value>Some weapons and plugs can have a \&quot;Breaker Type\&quot;: a special ability that works sort of like damage type vulnerabilities. This is (almost?) always set on items by plugs.</value>
        [DataMember(Name = "breakerType", EmitDefaultValue = false)]
        public int BreakerType { get; set; }

        /// <summary>
        /// Since we also have a breaker type definition, this is the hash for that breaker type for your convenience. Whether you use the enum or hash and look up the definition depends on what&#39;s cleanest for your code.
        /// </summary>
        /// <value>Since we also have a breaker type definition, this is the hash for that breaker type for your convenience. Whether you use the enum or hash and look up the definition depends on what&#39;s cleanest for your code.</value>
        [DataMember(Name = "breakerTypeHash", EmitDefaultValue = true)]
        public int? BreakerTypeHash { get; set; }

        /// <summary>
        /// If true, then you will be allowed to equip the item if you pass its other requirements.  This being false means that you cannot equip the item under any circumstances.
        /// </summary>
        /// <value>If true, then you will be allowed to equip the item if you pass its other requirements.  This being false means that you cannot equip the item under any circumstances.</value>
        [DataMember(Name = "equippable", EmitDefaultValue = true)]
        public bool Equippable { get; set; }

        /// <summary>
        /// Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.
        /// </summary>
        /// <value>Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.</value>
        [DataMember(Name = "damageTypeHashes", EmitDefaultValue = false)]
        public List<int> DamageTypeHashes { get; set; }

        /// <summary>
        /// This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.  This damage type prediction will only use the following to determine potential damage types:  - Intrinsic perks  - Talent Node perks  - Known, reusable plugs for sockets
        /// </summary>
        /// <value>This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.  This damage type prediction will only use the following to determine potential damage types:  - Intrinsic perks  - Talent Node perks  - Known, reusable plugs for sockets</value>
        [DataMember(Name = "damageTypes", EmitDefaultValue = false)]
        public List<int> DamageTypes { get; set; }

        /// <summary>
        /// If the item has a damage type that could be considered to be default, it will be populated here.  For various upsetting reasons, it&#39;s surprisingly cumbersome to figure this out. I hope you&#39;re happy.
        /// </summary>
        /// <value>If the item has a damage type that could be considered to be default, it will be populated here.  For various upsetting reasons, it&#39;s surprisingly cumbersome to figure this out. I hope you&#39;re happy.</value>
        [DataMember(Name = "defaultDamageType", EmitDefaultValue = false)]
        public int DefaultDamageType { get; set; }

        /// <summary>
        /// Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.  I will likely regret leaving in the enumeration versions of these properties, but for now they&#39;re very convenient.
        /// </summary>
        /// <value>Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.  I will likely regret leaving in the enumeration versions of these properties, but for now they&#39;re very convenient.</value>
        [DataMember(Name = "defaultDamageTypeHash", EmitDefaultValue = true)]
        public int? DefaultDamageTypeHash { get; set; }

        /// <summary>
        /// If this item is related directly to a Season of Destiny, this is the hash identifier for that season.
        /// </summary>
        /// <value>If this item is related directly to a Season of Destiny, this is the hash identifier for that season.</value>
        [DataMember(Name = "seasonHash", EmitDefaultValue = true)]
        public int? SeasonHash { get; set; }

        /// <summary>
        /// If true, this is a dummy vendor-wrapped item template. Items purchased from Eververse will be \&quot;wrapped\&quot; by one of these items so that we can safely provide refund capabilities before the item is \&quot;unwrapped\&quot;.
        /// </summary>
        /// <value>If true, this is a dummy vendor-wrapped item template. Items purchased from Eververse will be \&quot;wrapped\&quot; by one of these items so that we can safely provide refund capabilities before the item is \&quot;unwrapped\&quot;.</value>
        [DataMember(Name = "isWrapper", EmitDefaultValue = true)]
        public bool IsWrapper { get; set; }

        /// <summary>
        /// Traits are metadata tags applied to this item. For example: armor slot, weapon type, foundry, faction, etc. These IDs come from the game and don&#39;t map to any content, but should still be useful.
        /// </summary>
        /// <value>Traits are metadata tags applied to this item. For example: armor slot, weapon type, foundry, faction, etc. These IDs come from the game and don&#39;t map to any content, but should still be useful.</value>
        [DataMember(Name = "traitIds", EmitDefaultValue = false)]
        public List<string> TraitIds { get; set; }

        /// <summary>
        /// These are the corresponding trait definition hashes for the entries in traitIds.
        /// </summary>
        /// <value>These are the corresponding trait definition hashes for the entries in traitIds.</value>
        [DataMember(Name = "traitHashes", EmitDefaultValue = false)]
        public List<int> TraitHashes { get; set; }

        /// <summary>
        /// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
        /// </summary>
        /// <value>The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.</value>
        [DataMember(Name = "hash", EmitDefaultValue = false)]
        public int Hash { get; set; }

        /// <summary>
        /// The index of the entity as it was found in the investment tables.
        /// </summary>
        /// <value>The index of the entity as it was found in the investment tables.</value>
        [DataMember(Name = "index", EmitDefaultValue = false)]
        public int Index { get; set; }

        /// <summary>
        /// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
        /// </summary>
        /// <value>If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!</value>
        [DataMember(Name = "redacted", EmitDefaultValue = true)]
        public bool Redacted { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DestinyDefinitionsDestinyInventoryItemDefinition {\n");
            sb.Append("  DisplayProperties: ").Append(DisplayProperties).Append("\n");
            sb.Append("  TooltipNotifications: ").Append(TooltipNotifications).Append("\n");
            sb.Append("  CollectibleHash: ").Append(CollectibleHash).Append("\n");
            sb.Append("  IconWatermark: ").Append(IconWatermark).Append("\n");
            sb.Append("  IconWatermarkShelved: ").Append(IconWatermarkShelved).Append("\n");
            sb.Append("  SecondaryIcon: ").Append(SecondaryIcon).Append("\n");
            sb.Append("  SecondaryOverlay: ").Append(SecondaryOverlay).Append("\n");
            sb.Append("  SecondarySpecial: ").Append(SecondarySpecial).Append("\n");
            sb.Append("  BackgroundColor: ").Append(BackgroundColor).Append("\n");
            sb.Append("  Screenshot: ").Append(Screenshot).Append("\n");
            sb.Append("  ItemTypeDisplayName: ").Append(ItemTypeDisplayName).Append("\n");
            sb.Append("  FlavorText: ").Append(FlavorText).Append("\n");
            sb.Append("  UiItemDisplayStyle: ").Append(UiItemDisplayStyle).Append("\n");
            sb.Append("  ItemTypeAndTierDisplayName: ").Append(ItemTypeAndTierDisplayName).Append("\n");
            sb.Append("  DisplaySource: ").Append(DisplaySource).Append("\n");
            sb.Append("  TooltipStyle: ").Append(TooltipStyle).Append("\n");
            sb.Append("  Action: ").Append(Action).Append("\n");
            sb.Append("  Crafting: ").Append(Crafting).Append("\n");
            sb.Append("  Inventory: ").Append(Inventory).Append("\n");
            sb.Append("  SetData: ").Append(SetData).Append("\n");
            sb.Append("  Stats: ").Append(Stats).Append("\n");
            sb.Append("  EmblemObjectiveHash: ").Append(EmblemObjectiveHash).Append("\n");
            sb.Append("  EquippingBlock: ").Append(EquippingBlock).Append("\n");
            sb.Append("  TranslationBlock: ").Append(TranslationBlock).Append("\n");
            sb.Append("  Preview: ").Append(Preview).Append("\n");
            sb.Append("  Quality: ").Append(Quality).Append("\n");
            sb.Append("  Value: ").Append(Value).Append("\n");
            sb.Append("  SourceData: ").Append(SourceData).Append("\n");
            sb.Append("  Objectives: ").Append(Objectives).Append("\n");
            sb.Append("  Metrics: ").Append(Metrics).Append("\n");
            sb.Append("  Plug: ").Append(Plug).Append("\n");
            sb.Append("  Gearset: ").Append(Gearset).Append("\n");
            sb.Append("  Sack: ").Append(Sack).Append("\n");
            sb.Append("  Sockets: ").Append(Sockets).Append("\n");
            sb.Append("  Summary: ").Append(Summary).Append("\n");
            sb.Append("  TalentGrid: ").Append(TalentGrid).Append("\n");
            sb.Append("  InvestmentStats: ").Append(InvestmentStats).Append("\n");
            sb.Append("  Perks: ").Append(Perks).Append("\n");
            sb.Append("  LoreHash: ").Append(LoreHash).Append("\n");
            sb.Append("  SummaryItemHash: ").Append(SummaryItemHash).Append("\n");
            sb.Append("  Animations: ").Append(Animations).Append("\n");
            sb.Append("  AllowActions: ").Append(AllowActions).Append("\n");
            sb.Append("  Links: ").Append(Links).Append("\n");
            sb.Append("  DoesPostmasterPullHaveSideEffects: ").Append(DoesPostmasterPullHaveSideEffects).Append("\n");
            sb.Append("  NonTransferrable: ").Append(NonTransferrable).Append("\n");
            sb.Append("  ItemCategoryHashes: ").Append(ItemCategoryHashes).Append("\n");
            sb.Append("  SpecialItemType: ").Append(SpecialItemType).Append("\n");
            sb.Append("  ItemType: ").Append(ItemType).Append("\n");
            sb.Append("  ItemSubType: ").Append(ItemSubType).Append("\n");
            sb.Append("  ClassType: ").Append(ClassType).Append("\n");
            sb.Append("  BreakerType: ").Append(BreakerType).Append("\n");
            sb.Append("  BreakerTypeHash: ").Append(BreakerTypeHash).Append("\n");
            sb.Append("  Equippable: ").Append(Equippable).Append("\n");
            sb.Append("  DamageTypeHashes: ").Append(DamageTypeHashes).Append("\n");
            sb.Append("  DamageTypes: ").Append(DamageTypes).Append("\n");
            sb.Append("  DefaultDamageType: ").Append(DefaultDamageType).Append("\n");
            sb.Append("  DefaultDamageTypeHash: ").Append(DefaultDamageTypeHash).Append("\n");
            sb.Append("  SeasonHash: ").Append(SeasonHash).Append("\n");
            sb.Append("  IsWrapper: ").Append(IsWrapper).Append("\n");
            sb.Append("  TraitIds: ").Append(TraitIds).Append("\n");
            sb.Append("  TraitHashes: ").Append(TraitHashes).Append("\n");
            sb.Append("  Hash: ").Append(Hash).Append("\n");
            sb.Append("  Index: ").Append(Index).Append("\n");
            sb.Append("  Redacted: ").Append(Redacted).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as DestinyDefinitionsDestinyInventoryItemDefinition);
        }

        /// <summary>
        /// Returns true if DestinyDefinitionsDestinyInventoryItemDefinition instances are equal
        /// </summary>
        /// <param name="input">Instance of DestinyDefinitionsDestinyInventoryItemDefinition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(DestinyDefinitionsDestinyInventoryItemDefinition input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.DisplayProperties == input.DisplayProperties ||
                    (this.DisplayProperties != null &&
                    this.DisplayProperties.Equals(input.DisplayProperties))
                ) && 
                (
                    this.TooltipNotifications == input.TooltipNotifications ||
                    this.TooltipNotifications != null &&
                    input.TooltipNotifications != null &&
                    this.TooltipNotifications.SequenceEqual(input.TooltipNotifications)
                ) && 
                (
                    this.CollectibleHash == input.CollectibleHash ||
                    (this.CollectibleHash != null &&
                    this.CollectibleHash.Equals(input.CollectibleHash))
                ) && 
                (
                    this.IconWatermark == input.IconWatermark ||
                    (this.IconWatermark != null &&
                    this.IconWatermark.Equals(input.IconWatermark))
                ) && 
                (
                    this.IconWatermarkShelved == input.IconWatermarkShelved ||
                    (this.IconWatermarkShelved != null &&
                    this.IconWatermarkShelved.Equals(input.IconWatermarkShelved))
                ) && 
                (
                    this.SecondaryIcon == input.SecondaryIcon ||
                    (this.SecondaryIcon != null &&
                    this.SecondaryIcon.Equals(input.SecondaryIcon))
                ) && 
                (
                    this.SecondaryOverlay == input.SecondaryOverlay ||
                    (this.SecondaryOverlay != null &&
                    this.SecondaryOverlay.Equals(input.SecondaryOverlay))
                ) && 
                (
                    this.SecondarySpecial == input.SecondarySpecial ||
                    (this.SecondarySpecial != null &&
                    this.SecondarySpecial.Equals(input.SecondarySpecial))
                ) && 
                (
                    this.BackgroundColor == input.BackgroundColor ||
                    (this.BackgroundColor != null &&
                    this.BackgroundColor.Equals(input.BackgroundColor))
                ) && 
                (
                    this.Screenshot == input.Screenshot ||
                    (this.Screenshot != null &&
                    this.Screenshot.Equals(input.Screenshot))
                ) && 
                (
                    this.ItemTypeDisplayName == input.ItemTypeDisplayName ||
                    (this.ItemTypeDisplayName != null &&
                    this.ItemTypeDisplayName.Equals(input.ItemTypeDisplayName))
                ) && 
                (
                    this.FlavorText == input.FlavorText ||
                    (this.FlavorText != null &&
                    this.FlavorText.Equals(input.FlavorText))
                ) && 
                (
                    this.UiItemDisplayStyle == input.UiItemDisplayStyle ||
                    (this.UiItemDisplayStyle != null &&
                    this.UiItemDisplayStyle.Equals(input.UiItemDisplayStyle))
                ) && 
                (
                    this.ItemTypeAndTierDisplayName == input.ItemTypeAndTierDisplayName ||
                    (this.ItemTypeAndTierDisplayName != null &&
                    this.ItemTypeAndTierDisplayName.Equals(input.ItemTypeAndTierDisplayName))
                ) && 
                (
                    this.DisplaySource == input.DisplaySource ||
                    (this.DisplaySource != null &&
                    this.DisplaySource.Equals(input.DisplaySource))
                ) && 
                (
                    this.TooltipStyle == input.TooltipStyle ||
                    (this.TooltipStyle != null &&
                    this.TooltipStyle.Equals(input.TooltipStyle))
                ) && 
                (
                    this.Action == input.Action ||
                    (this.Action != null &&
                    this.Action.Equals(input.Action))
                ) && 
                (
                    this.Crafting == input.Crafting ||
                    (this.Crafting != null &&
                    this.Crafting.Equals(input.Crafting))
                ) && 
                (
                    this.Inventory == input.Inventory ||
                    (this.Inventory != null &&
                    this.Inventory.Equals(input.Inventory))
                ) && 
                (
                    this.SetData == input.SetData ||
                    (this.SetData != null &&
                    this.SetData.Equals(input.SetData))
                ) && 
                (
                    this.Stats == input.Stats ||
                    (this.Stats != null &&
                    this.Stats.Equals(input.Stats))
                ) && 
                (
                    this.EmblemObjectiveHash == input.EmblemObjectiveHash ||
                    (this.EmblemObjectiveHash != null &&
                    this.EmblemObjectiveHash.Equals(input.EmblemObjectiveHash))
                ) && 
                (
                    this.EquippingBlock == input.EquippingBlock ||
                    (this.EquippingBlock != null &&
                    this.EquippingBlock.Equals(input.EquippingBlock))
                ) && 
                (
                    this.TranslationBlock == input.TranslationBlock ||
                    (this.TranslationBlock != null &&
                    this.TranslationBlock.Equals(input.TranslationBlock))
                ) && 
                (
                    this.Preview == input.Preview ||
                    (this.Preview != null &&
                    this.Preview.Equals(input.Preview))
                ) && 
                (
                    this.Quality == input.Quality ||
                    (this.Quality != null &&
                    this.Quality.Equals(input.Quality))
                ) && 
                (
                    this.Value == input.Value ||
                    (this.Value != null &&
                    this.Value.Equals(input.Value))
                ) && 
                (
                    this.SourceData == input.SourceData ||
                    (this.SourceData != null &&
                    this.SourceData.Equals(input.SourceData))
                ) && 
                (
                    this.Objectives == input.Objectives ||
                    (this.Objectives != null &&
                    this.Objectives.Equals(input.Objectives))
                ) && 
                (
                    this.Metrics == input.Metrics ||
                    (this.Metrics != null &&
                    this.Metrics.Equals(input.Metrics))
                ) && 
                (
                    this.Plug == input.Plug ||
                    (this.Plug != null &&
                    this.Plug.Equals(input.Plug))
                ) && 
                (
                    this.Gearset == input.Gearset ||
                    (this.Gearset != null &&
                    this.Gearset.Equals(input.Gearset))
                ) && 
                (
                    this.Sack == input.Sack ||
                    (this.Sack != null &&
                    this.Sack.Equals(input.Sack))
                ) && 
                (
                    this.Sockets == input.Sockets ||
                    (this.Sockets != null &&
                    this.Sockets.Equals(input.Sockets))
                ) && 
                (
                    this.Summary == input.Summary ||
                    (this.Summary != null &&
                    this.Summary.Equals(input.Summary))
                ) && 
                (
                    this.TalentGrid == input.TalentGrid ||
                    (this.TalentGrid != null &&
                    this.TalentGrid.Equals(input.TalentGrid))
                ) && 
                (
                    this.InvestmentStats == input.InvestmentStats ||
                    this.InvestmentStats != null &&
                    input.InvestmentStats != null &&
                    this.InvestmentStats.SequenceEqual(input.InvestmentStats)
                ) && 
                (
                    this.Perks == input.Perks ||
                    this.Perks != null &&
                    input.Perks != null &&
                    this.Perks.SequenceEqual(input.Perks)
                ) && 
                (
                    this.LoreHash == input.LoreHash ||
                    (this.LoreHash != null &&
                    this.LoreHash.Equals(input.LoreHash))
                ) && 
                (
                    this.SummaryItemHash == input.SummaryItemHash ||
                    (this.SummaryItemHash != null &&
                    this.SummaryItemHash.Equals(input.SummaryItemHash))
                ) && 
                (
                    this.Animations == input.Animations ||
                    this.Animations != null &&
                    input.Animations != null &&
                    this.Animations.SequenceEqual(input.Animations)
                ) && 
                (
                    this.AllowActions == input.AllowActions ||
                    this.AllowActions.Equals(input.AllowActions)
                ) && 
                (
                    this.Links == input.Links ||
                    this.Links != null &&
                    input.Links != null &&
                    this.Links.SequenceEqual(input.Links)
                ) && 
                (
                    this.DoesPostmasterPullHaveSideEffects == input.DoesPostmasterPullHaveSideEffects ||
                    this.DoesPostmasterPullHaveSideEffects.Equals(input.DoesPostmasterPullHaveSideEffects)
                ) && 
                (
                    this.NonTransferrable == input.NonTransferrable ||
                    this.NonTransferrable.Equals(input.NonTransferrable)
                ) && 
                (
                    this.ItemCategoryHashes == input.ItemCategoryHashes ||
                    this.ItemCategoryHashes != null &&
                    input.ItemCategoryHashes != null &&
                    this.ItemCategoryHashes.SequenceEqual(input.ItemCategoryHashes)
                ) && 
                (
                    this.SpecialItemType == input.SpecialItemType ||
                    this.SpecialItemType.Equals(input.SpecialItemType)
                ) && 
                (
                    this.ItemType == input.ItemType ||
                    this.ItemType.Equals(input.ItemType)
                ) && 
                (
                    this.ItemSubType == input.ItemSubType ||
                    this.ItemSubType.Equals(input.ItemSubType)
                ) && 
                (
                    this.ClassType == input.ClassType ||
                    this.ClassType.Equals(input.ClassType)
                ) && 
                (
                    this.BreakerType == input.BreakerType ||
                    this.BreakerType.Equals(input.BreakerType)
                ) && 
                (
                    this.BreakerTypeHash == input.BreakerTypeHash ||
                    (this.BreakerTypeHash != null &&
                    this.BreakerTypeHash.Equals(input.BreakerTypeHash))
                ) && 
                (
                    this.Equippable == input.Equippable ||
                    this.Equippable.Equals(input.Equippable)
                ) && 
                (
                    this.DamageTypeHashes == input.DamageTypeHashes ||
                    this.DamageTypeHashes != null &&
                    input.DamageTypeHashes != null &&
                    this.DamageTypeHashes.SequenceEqual(input.DamageTypeHashes)
                ) && 
                (
                    this.DamageTypes == input.DamageTypes ||
                    this.DamageTypes != null &&
                    input.DamageTypes != null &&
                    this.DamageTypes.SequenceEqual(input.DamageTypes)
                ) && 
                (
                    this.DefaultDamageType == input.DefaultDamageType ||
                    this.DefaultDamageType.Equals(input.DefaultDamageType)
                ) && 
                (
                    this.DefaultDamageTypeHash == input.DefaultDamageTypeHash ||
                    (this.DefaultDamageTypeHash != null &&
                    this.DefaultDamageTypeHash.Equals(input.DefaultDamageTypeHash))
                ) && 
                (
                    this.SeasonHash == input.SeasonHash ||
                    (this.SeasonHash != null &&
                    this.SeasonHash.Equals(input.SeasonHash))
                ) && 
                (
                    this.IsWrapper == input.IsWrapper ||
                    this.IsWrapper.Equals(input.IsWrapper)
                ) && 
                (
                    this.TraitIds == input.TraitIds ||
                    this.TraitIds != null &&
                    input.TraitIds != null &&
                    this.TraitIds.SequenceEqual(input.TraitIds)
                ) && 
                (
                    this.TraitHashes == input.TraitHashes ||
                    this.TraitHashes != null &&
                    input.TraitHashes != null &&
                    this.TraitHashes.SequenceEqual(input.TraitHashes)
                ) && 
                (
                    this.Hash == input.Hash ||
                    this.Hash.Equals(input.Hash)
                ) && 
                (
                    this.Index == input.Index ||
                    this.Index.Equals(input.Index)
                ) && 
                (
                    this.Redacted == input.Redacted ||
                    this.Redacted.Equals(input.Redacted)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.DisplayProperties != null)
                {
                    hashCode = (hashCode * 59) + this.DisplayProperties.GetHashCode();
                }
                if (this.TooltipNotifications != null)
                {
                    hashCode = (hashCode * 59) + this.TooltipNotifications.GetHashCode();
                }
                if (this.CollectibleHash != null)
                {
                    hashCode = (hashCode * 59) + this.CollectibleHash.GetHashCode();
                }
                if (this.IconWatermark != null)
                {
                    hashCode = (hashCode * 59) + this.IconWatermark.GetHashCode();
                }
                if (this.IconWatermarkShelved != null)
                {
                    hashCode = (hashCode * 59) + this.IconWatermarkShelved.GetHashCode();
                }
                if (this.SecondaryIcon != null)
                {
                    hashCode = (hashCode * 59) + this.SecondaryIcon.GetHashCode();
                }
                if (this.SecondaryOverlay != null)
                {
                    hashCode = (hashCode * 59) + this.SecondaryOverlay.GetHashCode();
                }
                if (this.SecondarySpecial != null)
                {
                    hashCode = (hashCode * 59) + this.SecondarySpecial.GetHashCode();
                }
                if (this.BackgroundColor != null)
                {
                    hashCode = (hashCode * 59) + this.BackgroundColor.GetHashCode();
                }
                if (this.Screenshot != null)
                {
                    hashCode = (hashCode * 59) + this.Screenshot.GetHashCode();
                }
                if (this.ItemTypeDisplayName != null)
                {
                    hashCode = (hashCode * 59) + this.ItemTypeDisplayName.GetHashCode();
                }
                if (this.FlavorText != null)
                {
                    hashCode = (hashCode * 59) + this.FlavorText.GetHashCode();
                }
                if (this.UiItemDisplayStyle != null)
                {
                    hashCode = (hashCode * 59) + this.UiItemDisplayStyle.GetHashCode();
                }
                if (this.ItemTypeAndTierDisplayName != null)
                {
                    hashCode = (hashCode * 59) + this.ItemTypeAndTierDisplayName.GetHashCode();
                }
                if (this.DisplaySource != null)
                {
                    hashCode = (hashCode * 59) + this.DisplaySource.GetHashCode();
                }
                if (this.TooltipStyle != null)
                {
                    hashCode = (hashCode * 59) + this.TooltipStyle.GetHashCode();
                }
                if (this.Action != null)
                {
                    hashCode = (hashCode * 59) + this.Action.GetHashCode();
                }
                if (this.Crafting != null)
                {
                    hashCode = (hashCode * 59) + this.Crafting.GetHashCode();
                }
                if (this.Inventory != null)
                {
                    hashCode = (hashCode * 59) + this.Inventory.GetHashCode();
                }
                if (this.SetData != null)
                {
                    hashCode = (hashCode * 59) + this.SetData.GetHashCode();
                }
                if (this.Stats != null)
                {
                    hashCode = (hashCode * 59) + this.Stats.GetHashCode();
                }
                if (this.EmblemObjectiveHash != null)
                {
                    hashCode = (hashCode * 59) + this.EmblemObjectiveHash.GetHashCode();
                }
                if (this.EquippingBlock != null)
                {
                    hashCode = (hashCode * 59) + this.EquippingBlock.GetHashCode();
                }
                if (this.TranslationBlock != null)
                {
                    hashCode = (hashCode * 59) + this.TranslationBlock.GetHashCode();
                }
                if (this.Preview != null)
                {
                    hashCode = (hashCode * 59) + this.Preview.GetHashCode();
                }
                if (this.Quality != null)
                {
                    hashCode = (hashCode * 59) + this.Quality.GetHashCode();
                }
                if (this.Value != null)
                {
                    hashCode = (hashCode * 59) + this.Value.GetHashCode();
                }
                if (this.SourceData != null)
                {
                    hashCode = (hashCode * 59) + this.SourceData.GetHashCode();
                }
                if (this.Objectives != null)
                {
                    hashCode = (hashCode * 59) + this.Objectives.GetHashCode();
                }
                if (this.Metrics != null)
                {
                    hashCode = (hashCode * 59) + this.Metrics.GetHashCode();
                }
                if (this.Plug != null)
                {
                    hashCode = (hashCode * 59) + this.Plug.GetHashCode();
                }
                if (this.Gearset != null)
                {
                    hashCode = (hashCode * 59) + this.Gearset.GetHashCode();
                }
                if (this.Sack != null)
                {
                    hashCode = (hashCode * 59) + this.Sack.GetHashCode();
                }
                if (this.Sockets != null)
                {
                    hashCode = (hashCode * 59) + this.Sockets.GetHashCode();
                }
                if (this.Summary != null)
                {
                    hashCode = (hashCode * 59) + this.Summary.GetHashCode();
                }
                if (this.TalentGrid != null)
                {
                    hashCode = (hashCode * 59) + this.TalentGrid.GetHashCode();
                }
                if (this.InvestmentStats != null)
                {
                    hashCode = (hashCode * 59) + this.InvestmentStats.GetHashCode();
                }
                if (this.Perks != null)
                {
                    hashCode = (hashCode * 59) + this.Perks.GetHashCode();
                }
                if (this.LoreHash != null)
                {
                    hashCode = (hashCode * 59) + this.LoreHash.GetHashCode();
                }
                if (this.SummaryItemHash != null)
                {
                    hashCode = (hashCode * 59) + this.SummaryItemHash.GetHashCode();
                }
                if (this.Animations != null)
                {
                    hashCode = (hashCode * 59) + this.Animations.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.AllowActions.GetHashCode();
                if (this.Links != null)
                {
                    hashCode = (hashCode * 59) + this.Links.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.DoesPostmasterPullHaveSideEffects.GetHashCode();
                hashCode = (hashCode * 59) + this.NonTransferrable.GetHashCode();
                if (this.ItemCategoryHashes != null)
                {
                    hashCode = (hashCode * 59) + this.ItemCategoryHashes.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.SpecialItemType.GetHashCode();
                hashCode = (hashCode * 59) + this.ItemType.GetHashCode();
                hashCode = (hashCode * 59) + this.ItemSubType.GetHashCode();
                hashCode = (hashCode * 59) + this.ClassType.GetHashCode();
                hashCode = (hashCode * 59) + this.BreakerType.GetHashCode();
                if (this.BreakerTypeHash != null)
                {
                    hashCode = (hashCode * 59) + this.BreakerTypeHash.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Equippable.GetHashCode();
                if (this.DamageTypeHashes != null)
                {
                    hashCode = (hashCode * 59) + this.DamageTypeHashes.GetHashCode();
                }
                if (this.DamageTypes != null)
                {
                    hashCode = (hashCode * 59) + this.DamageTypes.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.DefaultDamageType.GetHashCode();
                if (this.DefaultDamageTypeHash != null)
                {
                    hashCode = (hashCode * 59) + this.DefaultDamageTypeHash.GetHashCode();
                }
                if (this.SeasonHash != null)
                {
                    hashCode = (hashCode * 59) + this.SeasonHash.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.IsWrapper.GetHashCode();
                if (this.TraitIds != null)
                {
                    hashCode = (hashCode * 59) + this.TraitIds.GetHashCode();
                }
                if (this.TraitHashes != null)
                {
                    hashCode = (hashCode * 59) + this.TraitHashes.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.Hash.GetHashCode();
                hashCode = (hashCode * 59) + this.Index.GetHashCode();
                hashCode = (hashCode * 59) + this.Redacted.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
